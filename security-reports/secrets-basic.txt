./internal/diagnostics/worker_pool_security_test.go:31:		{name: "worker_1_data", workerData: "worker_1_secret", shouldLeak: false},
./internal/diagnostics/worker_pool_security_test.go:32:		{name: "worker_2_data", workerData: "worker_2_secret", shouldLeak: false},
./internal/diagnostics/worker_pool_security_test.go:33:		{name: "worker_3_data", workerData: "worker_3_secret", shouldLeak: false},
./internal/diagnostics/worker_pool_security_test.go:62:		secretCount := 0
./internal/diagnostics/worker_pool_security_test.go:65:				secretCount++
./internal/diagnostics/worker_pool_security_test.go:69:		assert.LessOrEqual(t, secretCount, 1, "Worker should only access its own data")
./internal/diagnostics/worker_pool_security_test.go:913:		key := fmt.Sprintf("key_%d", i)
./internal/diagnostics/worker_pool_security_test.go:914:		data[key] = make([]byte, 1024)
./internal/diagnostics/worker_pool_security_test.go:918:	for key := range data {
./internal/diagnostics/worker_pool_security_test.go:919:		delete(data, key)
./internal/diagnostics/rate_limiter_docker_integration_test.go:310:		time.Sleep(800 * time.Millisecond) // Allow token replenishment
./internal/diagnostics/rate_limiter_docker_integration_test.go:345:			RequestsPerSecond: 4.0, // 250ms per token
./internal/diagnostics/rate_limiter_docker_integration_test.go:355:		// Simulate operations that hold tokens for extended periods
./internal/diagnostics/rate_limiter_docker_integration_test.go:430:			RequestsPerSecond: 6.0, // 167ms per token
./internal/diagnostics/timing_storage.go:364:func (ts *TimingStorage) removeTimingFromSlice(slice []*TimingData, timing *TimingData, key interface{}, indexType string) {
./internal/diagnostics/timing_storage.go:374:				if keyStr, ok := key.(string); ok {
./internal/diagnostics/timing_storage.go:375:					ts.byCategory[keyStr] = slice
./internal/diagnostics/timing_storage.go:378:				if keyStr, ok := key.(string); ok {
./internal/diagnostics/timing_storage.go:379:					ts.byCheck[keyStr] = slice
./internal/diagnostics/timing_storage.go:382:				if keyInt, ok := key.(int); ok {
./internal/diagnostics/timing_storage.go:383:					ts.byWorker[keyInt] = slice
./internal/diagnostics/rate_limiter_comprehensive_test.go:281:			RequestsPerSecond: 4.0, // 250ms per token
./internal/diagnostics/rate_limiter.go:25:	WaitTimeout       time.Duration // Maximum wait time for a token
./internal/diagnostics/rate_limiter.go:69:// Wait blocks until a token is available or the context is cancelled
./internal/diagnostics/rate_limiter.go:93:	// Wait for token
./internal/diagnostics/rate_limiter.go:111:// TryAcquire attempts to acquire a token without blocking
./internal/diagnostics/rate_limiter.go:127:	// Try to acquire token
./internal/diagnostics/rate_limiter.go:143:// Reserve reserves a token for future use
./internal/diagnostics/rate_limiter_benchmark_test.go:233:		RequestsPerSecond: 4.0, // 4 req/sec = 250ms per token
./internal/diagnostics/rate_limiter_benchmark_test.go:244:			t.Fatalf("Failed to acquire burst token %d", i+1)
./internal/diagnostics/rate_limiter_benchmark_test.go:257:		{200 * time.Millisecond, false, "before first token recovery"},
./internal/diagnostics/rate_limiter_benchmark_test.go:258:		{300 * time.Millisecond, true, "after first token recovery"},
./internal/diagnostics/rate_limiter_benchmark_test.go:259:		{250 * time.Millisecond, true, "after second token recovery"},
./internal/diagnostics/rate_limiter_benchmark_test.go:260:		{250 * time.Millisecond, true, "after third token recovery"},
./internal/diagnostics/rate_limiter_benchmark_test.go:354:		RequestsPerSecond: 5.0, // 200ms per token
./internal/diagnostics/rate_limiter_benchmark_test.go:428:		RequestsPerSecond: 2.0, // 500ms per token
./internal/diagnostics/rate_limiter_benchmark_test.go:439:		t.Fatal("Failed to acquire initial token")
./internal/diagnostics/connectivity_checks.go:174:			// Build the port key for conflict detection
./internal/diagnostics/connectivity_checks.go:175:			portKey := fmt.Sprintf("%d/%s", port.PublicPort, port.Type)
./internal/diagnostics/connectivity_checks.go:177:				portKey = fmt.Sprintf("%s:%s", port.IP, portKey)
./internal/diagnostics/connectivity_checks.go:185:			portConflicts[portKey] = append(portConflicts[portKey], containerName)
./internal/diagnostics/connectivity_checks_test.go:233:				for key := range tc.execResults {
./internal/diagnostics/connectivity_checks_test.go:234:					parts := strings.Split(key, "_")
./internal/diagnostics/connectivity_checks_test.go:373:						key := fmt.Sprintf("%s:%d/%s", port.IP, port.PublicPort, port.Type)
./internal/diagnostics/connectivity_checks_test.go:374:						portMap[key] = append(portMap[key], container.Names[0])
./internal/diagnostics/tests/security_validator_test.go:807:			"password_secret_check",
./internal/diagnostics/system_checks_coverage_test.go:142:			ctx := context.WithValue(context.Background(), "key", "value")
./internal/diagnostics/system_checks_coverage_test.go:252:				result.Details["test_key"] = "test_value"
./internal/diagnostics/rate_limiter_test.go:214:	// Wait for one token to replenish
./internal/diagnostics/rate_limiter_test.go:219:		t.Error("Expected one request to be allowed after token replenishment")
./internal/diagnostics/rate_limiter_test.go:231:		RequestsPerSecond: 10.0, // 10 req/sec = 100ms per token
./internal/diagnostics/rate_limiter_test.go:242:			t.Fatalf("Failed to acquire burst token %d", i+1)
./internal/diagnostics/rate_limiter_test.go:251:	// Wait for token replenishment (110ms should be enough for 100ms rate)
./internal/diagnostics/rate_limiter_test.go:256:		t.Error("Expected request to succeed after token replenishment")
./internal/diagnostics/rate_limiter_test.go:435:		t.Fatal("Failed to acquire initial token")
./internal/diagnostics/rate_limiter_test.go:484:		t.Fatal("Failed to acquire initial token")
./internal/diagnostics/rate_limiter_test.go:657:	// Should contain key information
./internal/diagnostics/rate_limiter_integration_test.go:239:			t.Errorf("Failed to acquire burst token %d", i+1)
./internal/diagnostics/rate_limiter_integration_test.go:263:	time.Sleep(500 * time.Millisecond) // Allow token replenishment
./internal/diagnostics/rate_limiter_integration_test.go:591:	// Should contain key metrics
./internal/docker/response_cache.go:50:func (c *ResponseCache) GetContainerList(key string) ([]types.Container, bool) {
./internal/docker/response_cache.go:54:	entry, exists := c.entries[key]
./internal/docker/response_cache.go:77:func (c *ResponseCache) SetContainerList(key string, containers []types.Container, ttl time.Duration) {
./internal/docker/response_cache.go:90:	c.entries[key] = &CacheEntry{
./internal/docker/response_cache.go:98:func (c *ResponseCache) GetNetworkList(key string) ([]network.Summary, bool) {
./internal/docker/response_cache.go:102:	entry, exists := c.entries[key]
./internal/docker/response_cache.go:125:func (c *ResponseCache) SetNetworkList(key string, networks []network.Summary, ttl time.Duration) {
./internal/docker/response_cache.go:138:	c.entries[key] = &CacheEntry{
./internal/docker/response_cache.go:150:	key := "network_inspect:" + networkID
./internal/docker/response_cache.go:151:	entry, exists := c.entries[key]
./internal/docker/response_cache.go:178:	key := "network_inspect:" + networkID
./internal/docker/response_cache.go:189:	c.entries[key] = &CacheEntry{
./internal/docker/response_cache.go:201:	key := "container_inspect:" + containerID
./internal/docker/response_cache.go:202:	entry, exists := c.entries[key]
./internal/docker/response_cache.go:229:	key := "container_inspect:" + containerID
./internal/docker/response_cache.go:240:	c.entries[key] = &CacheEntry{
./internal/docker/response_cache.go:248:func (c *ResponseCache) Invalidate(key string) {
./internal/docker/response_cache.go:252:	delete(c.entries, key)
./internal/docker/response_cache.go:284:	var oldestKey string
./internal/docker/response_cache.go:287:	for key, entry := range c.entries {
./internal/docker/response_cache.go:288:		if oldestKey == "" || entry.Timestamp.Before(oldestTime) {
./internal/docker/response_cache.go:289:			oldestKey = key
./internal/docker/response_cache.go:294:	if oldestKey != "" {
./internal/docker/response_cache.go:295:		delete(c.entries, oldestKey)
./internal/docker/response_cache.go:321:	keysToDelete := []string{}
./internal/docker/response_cache.go:323:	for key, entry := range c.entries {
./internal/docker/response_cache.go:325:			keysToDelete = append(keysToDelete, key)
./internal/docker/response_cache.go:329:	for _, key := range keysToDelete {
./internal/docker/response_cache.go:330:		delete(c.entries, key)
./internal/docker/response_cache.go:355:	CacheKey string
./internal/docker/response_cache.go:360:func (c *ResponseCache) GetOrCompute(ctx context.Context, key string, compute func() (interface{}, error), ttl time.Duration) (interface{}, error) {
./internal/docker/response_cache.go:363:	entry, exists := c.entries[key]
./internal/docker/response_cache.go:390:	c.entries[key] = &CacheEntry{
./internal/docker/response_cache_test.go:52:		_, found := cache.GetContainerList("test-key")
./internal/docker/response_cache_test.go:56:		cache.SetContainerList("test-key", containers, 5*time.Second)
./internal/docker/response_cache_test.go:59:		result, found := cache.GetContainerList("test-key")
./internal/docker/response_cache_test.go:66:	t.Run("DifferentKeys", func(t *testing.T) {
./internal/docker/response_cache_test.go:67:		cache.SetContainerList("key1", containers[:1], 5*time.Second)
./internal/docker/response_cache_test.go:68:		cache.SetContainerList("key2", containers[1:], 5*time.Second)
./internal/docker/response_cache_test.go:70:		result1, found1 := cache.GetContainerList("key1")
./internal/docker/response_cache_test.go:75:		result2, found2 := cache.GetContainerList("key2")
./internal/docker/response_cache_test.go:80:		// Non-existent key
./internal/docker/response_cache_test.go:81:		_, found3 := cache.GetContainerList("key3")
./internal/docker/response_cache_test.go:87:		cache.SetContainerList("expire-key", containers, 50*time.Millisecond)
./internal/docker/response_cache_test.go:90:		_, found := cache.GetContainerList("expire-key")
./internal/docker/response_cache_test.go:97:		_, found = cache.GetContainerList("expire-key")
./internal/docker/response_cache_test.go:132:		_, found := cache.GetNetworkList("net-key")
./internal/docker/response_cache_test.go:136:		cache.SetNetworkList("net-key", networks, 5*time.Second)
./internal/docker/response_cache_test.go:139:		result, found := cache.GetNetworkList("net-key")
./internal/docker/response_cache_test.go:249:		cache.SetContainerList("key1", containers, 5*time.Second)
./internal/docker/response_cache_test.go:250:		cache.SetContainerList("key2", containers, 5*time.Second)
./internal/docker/response_cache_test.go:251:		cache.SetContainerList("key3", containers, 5*time.Second)
./internal/docker/response_cache_test.go:258:		cache.SetContainerList("key4", containers, 5*time.Second)
./internal/docker/response_cache_test.go:265:		_, found1 := cache.GetContainerList("key1")
./internal/docker/response_cache_test.go:269:		_, found4 := cache.GetContainerList("key4")
./internal/docker/response_cache_test.go:283:		cache.SetContainerList("key1", containers, 5*time.Second)
./internal/docker/response_cache_test.go:284:		cache.SetContainerList("key2", containers, 5*time.Second)
./internal/docker/response_cache_test.go:287:		_, found1 := cache.GetContainerList("key1")
./internal/docker/response_cache_test.go:288:		_, found2 := cache.GetContainerList("key2")
./internal/docker/response_cache_test.go:293:		cache.Invalidate("key1")
./internal/docker/response_cache_test.go:295:		// key1 should be gone, key2 should remain
./internal/docker/response_cache_test.go:296:		_, found1 = cache.GetContainerList("key1")
./internal/docker/response_cache_test.go:297:		_, found2 = cache.GetContainerList("key2")
./internal/docker/response_cache_test.go:303:		cache.SetContainerList("key1", containers, 5*time.Second)
./internal/docker/response_cache_test.go:304:		cache.SetContainerList("key2", containers, 5*time.Second)
./internal/docker/response_cache_test.go:315:		_, found1 := cache.GetContainerList("key1")
./internal/docker/response_cache_test.go:316:		_, found2 := cache.GetContainerList("key2")
./internal/docker/response_cache_test.go:337:		_, found := cache.GetContainerList("miss-key")
./internal/docker/response_cache_test.go:345:		cache.SetContainerList("hit-key", containers, 5*time.Second)
./internal/docker/response_cache_test.go:348:		_, found = cache.GetContainerList("hit-key")
./internal/docker/response_cache_test.go:386:		result, err := cache.GetOrCompute(ctx, "compute-key", func() (interface{}, error) {
./internal/docker/response_cache_test.go:396:		result2, err := cache.GetOrCompute(ctx, "compute-key", func() (interface{}, error) {
./internal/docker/response_cache_test.go:410:		result, err := cache.GetOrCompute(ctx, "error-key", func() (interface{}, error) {
./internal/docker/response_cache_test.go:426:		result, err := cache.GetOrCompute(ctx, "default-ttl-key", func() (interface{}, error) {
./internal/docker/response_cache_test.go:489:					key := fmt.Sprintf("concurrent-%d-%d", goroutineID, j)
./internal/docker/response_cache_test.go:492:					cache.SetContainerList(key, containers, 5*time.Second)
./internal/docker/response_cache_test.go:495:					result, found := cache.GetContainerList(key)
./internal/docker/response_cache_test.go:512:			key := fmt.Sprintf("invalidate-test-%d", i)
./internal/docker/response_cache_test.go:513:			cache.SetContainerList(key, containers, 5*time.Second)
./internal/docker/response_cache_test.go:532:				key := fmt.Sprintf("invalidate-test-%d", id)
./internal/docker/response_cache_test.go:533:				_, _ = cache.GetContainerList(key)
./internal/docker/response_cache_test.go:556:		key := fmt.Sprintf("bench-key-%d", i)
./internal/docker/response_cache_test.go:557:		cache.SetContainerList(key, containers, 5*time.Second)
./internal/docker/response_cache_test.go:571:		key := fmt.Sprintf("bench-key-%d", i)
./internal/docker/response_cache_test.go:572:		cache.SetContainerList(key, containers, 5*time.Second)
./internal/docker/response_cache_test.go:577:		key := fmt.Sprintf("bench-key-%d", i%100)
./internal/docker/response_cache_test.go:578:		_, _ = cache.GetContainerList(key)
./internal/docker/response_cache_test.go:592:		key := fmt.Sprintf("bench-key-%d", i)
./internal/docker/response_cache_test.go:593:		cache.SetContainerList(key, containers, 5*time.Second)
./internal/docker/response_cache_test.go:600:			key := fmt.Sprintf("bench-key-%d", i%100)
./internal/docker/response_cache_test.go:601:			_, _ = cache.GetContainerList(key)
./internal/docker/client_enhanced.go:170:	cacheKey := "containers:all"
./internal/docker/client_enhanced.go:173:	if containers, found := ec.cache.GetContainerList(cacheKey); found {
./internal/docker/client_enhanced.go:201:	ec.cache.SetContainerList(cacheKey, containers, 30*time.Second)
./internal/docker/client_enhanced.go:297:	cacheKey := "container_network:" + containerID
./internal/docker/client_enhanced.go:300:	result, err := ec.cache.GetOrCompute(ctx, cacheKey, func() (interface{}, error) {
./internal/docker/client_enhanced_test.go:166:		// Different key should miss
./cmd/docker-net-doctor/main.go:343:            for key, value := range check.Details {
./cmd/docker-net-doctor/main.go:344:                fmt.Printf("      %s: %v\n", key, value)
